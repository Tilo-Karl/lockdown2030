{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 .SFNS-Regular;\f1\fnil\fcharset0 AppleColorEmoji;}
{\colortbl;\red255\green255\blue255;\red14\green14\blue14;}
{\*\expandedcolortbl;;\cssrgb\c6700\c6700\c6700;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 Big picture (world entities)\
\
- One canonical WorldEntity layer on the frontend (players, human NPCs, zombies, items all normalized).\
- Backend does not care if something is a \'93zombie\'94 or \'93human\'94 in terms of math \'96 just entity config + tags.\
- Humans:\
  - Player humans.\
  - Human NPCs (raiders, traders, later cannibals, factions, etc.).\
- Items:\
  - Weapons, armor, consumables and special items, tied to building types (police, shop, hospital\'85).\
- UI rows:\
  - Zombies row = WorldEntity where isZombie == true.\
  - Humans row = WorldEntity where isHuman == true (players + human NPCs).\
  - Items row = WorldEntity where isItem == true.\
- Selection:\
  - UI keeps InteractionKind (.zombie, .human, .item, .tile) for panel text.\
  - Under the hood: one canonical selection: selectedEntityId + selectedEntityKind (zombies/humans/items are just filtered views).\
\
\uc0\u11835 \
\
Short-term scope (right now)\
\
Goal: get a small but meaningful set of human NPCs + items wired into the backend so the world feels alive before touching the Swift frontend.\
\
Backend only, for this pass:\
\
Humans\
- Add two human NPC archetypes on top of PLAYER:\
  - RAIDER (hostile, higher damage, lower defense).\
  - TRADER (non-hostile, decent HP, maybe no attack for now).\
- Files:\
  - ld2030/v1/entity/entity-human.js\
    - Define HUMAN_RAIDER and HUMAN_TRADER (extend ACTOR_BASE).\
  - ld2030/v1/entity/index.js\
    - Add them to ENTITY_CONFIG.\
    - Teach resolveEntityConfig('HUMAN', 'RAIDER'/'TRADER') to return the right configs.\
\
Items\
- Focus on items from:\
  - Police station: weapon + armor.\
  - Shop: basic weapon/utility item.\
- No generic \'93clutter\'94 for now \'96 everything spawned should be potentially useful.\
- Files:\
  - ld2030/v1/entity/entity-item.js\
    - Add item templates such as:\
      - ITEM_WEAPON_POLICE_PISTOL\
      - ITEM_ARMOR_POLICE_VEST\
      - ITEM_WEAPON_SHOP_KNIFE (or bat/pipe).\
  - ld2030/v1/entity/index.js\
    - Add these items to ENTITY_CONFIG and resolveEntityConfig:\
      - resolveEntityConfig('ITEM', 'POLICE_WEAPON') \uc0\u8594  ITEM_WEAPON_POLICE_PISTOL\
      - resolveEntityConfig('ITEM', 'POLICE_ARMOR') \uc0\u8594  ITEM_ARMOR_POLICE_VEST\
      - resolveEntityConfig('ITEM', 'SHOP_WEAPON') \uc0\u8594  ITEM_WEAPON_SHOP_KNIFE\
\
Spawns\
- Make the existing spawn system actually use the new kinds:\
  - ld2030/v1/state.js\
    - Human spawn: random mix of CIVILIAN / RAIDER / TRADER.\
    - Item spawn: use a small table that can later be tied to building type:\
      - For now, just mix police-style and shop-style items on any non-water tile.\
    - Keep densities simple (same as now) but every spawned human/item should be one of the explicit configs above.\
\
After this backend pass:\
- /init-game will create:\
  - Zombies (as today).\
  - Human NPCs with meaningful roles (raider / trader).\
  - Useful items (police + shop flavored).\
- iOS can then start reading npcs/items and showing them via WorldEntity without more backend changes.\
\
\uc0\u11835 \
\
Backend unification \'97 DONE  \
- Unified PLAYER + ZOMBIE under entity configs.  \
- Normalized hp/alive logic.  \
- Shared attackEntity is live.  \
- Tick engine skips dead actors.  \
(No further backend unification work required.)\
\
Next backend step (NPCs + items) \'97 SINGLE PASS, no revisits  \
Files touched once:  \
\'95 ld2030/v1/entity/entity-human.js \'97 add HUMAN_RAIDER, HUMAN_TRADER  \
\'95 ld2030/v1/entity/entity-item.js \'97 add police + shop items (weapon, armor, knife/bat)  \
\'95 ld2030/v1/entity/index.js \'97 register new humans + items, extend resolveEntityConfig  \
\'95 ld2030/v1/state.js \'97 adjust spawn logic (mix RAIDER/TRADER; spawn police/shop items)  \
\
This completes backend NPC + item integration without reopening the same files later.\
---\
\
\
2. Frontend: WorldEntity layer in GameVM\
\
Files (Swift):\
	\'95	GameVM.swift\
	\'95	GameVM+Firestore.swift\
	\'95	(optionally) a new file GameVM+Entities.swift if you want to keep it clean\
\
Steps:\
	1.	Define enums + struct\
In GameVM:\
	\'95	enum EntityKind \{ case playerHuman, playerZombie, npcHuman, npcZombie, item \}\
	\'95	struct WorldEntity \{ id, kind, pos: Pos, hp, maxHp, ap, isMe, displayName, etc. \}\
	2.	Build worldEntities from existing arrays\
	\'95	In a computed property or a cached array:\
	\'95	Map players \uc0\u8594  WorldEntity (using EntityKind.playerHuman for now).\
	\'95	isMe = (player.userId == uid)\
	\'95	Map zombies \uc0\u8594  WorldEntity using zombie-config info if needed.\
No Firestore schema change, just a VM view.\
	3.	Tile helpers\
	\'95	Add helpers in GameVM:\
	\'95	entities(at pos: Pos) -> [WorldEntity]\
	\'95	zombies(at pos: Pos) -> [WorldEntity] (filter by kind)\
	\'95	humans(at pos: Pos) -> [WorldEntity]\
	\'95	items(at pos: Pos) -> [WorldEntity]\
These are what GridView will start using instead of reaching directly into players and zombies.\
\
\uc0\u11835 \
\
3. Frontend: unify selection state\
\
Files:\
	\'95	GameVM.swift\
	\'95	GameVM+Interaction.swift\
	\'95	GameVM+Tap.swift\
\
You already have:\
	\'95	interactionKind\
	\'95	interactionPos\
	\'95	selectedZombieId\
	\'95	selectedHumanId\
\
Plan:\
	1.	Introduce canonical selection\
	\'95	@Published var selectedEntityId: String?\
	\'95	@Published var selectedEntityKind: EntityKind?\
	2.	Have the old fields just wrap the new ones\
	\'95	For zombies:\
	\'95	Keep interactionKind == .zombie for UI\
	\'95	But under the hood: selectedEntityKind = .playerZombie / .npcZombie / .npcHuman etc.\
	\'95	Keep interactionZombie helper, but implement it via selectedEntityId and worldEntities.\
	3.	Tap handlers delegate to common selection logic\
In GameVM+Tap.swift:\
	\'95	handleZombieTapByIndex(pos, index) \uc0\u8594  find WorldEntity in zombies(at: pos) then call select(entity:).\
	\'95	handleHumanTapByIndex(pos, index) \uc0\u8594  find in humans(at: pos) and call the same select(entity:).\
Where select(entity:):\
	\'95	If already selected \uc0\u8594  clear selection.\
	\'95	Else set selectedEntityId, selectedEntityKind, interactionKind (zombie/human/item), interactionPos.\
	4.	Clear selection in one place\
	\'95	clearInteraction() becomes the only thing that resets:\
	\'95	interactionPos\
	\'95	interactionKind\
	\'95	selectedEntityId\
	\'95	selectedEntityKind\
\
\uc0\u11835 \
\
4. Frontend: GridView / GridCellView driven by WorldEntity\
\
Files:\
	\'95	GridView.swift\
	\'95	GridCellView.swift\
\
Steps:\
	1.	GridView uses worldEntities helpers\
In makeTileViewModel:\
	\'95	Get:\
	\'95	zombiesHere = vm.zombies(at: tilePos)\
	\'95	humansHere = vm.humans(at: tilePos)\
	\'95	(later) itemsHere = vm.items(at: tilePos)\
	\'95	Pass down:\
	\'95	zombieIds = zombiesHere.map(\\.id)\
	\'95	humanIds = humansHere.map(\\.id) (new)\
	\'95	selectedEntityId to highlight the right emoji.\
	2.	GridCellView gets per-entity info\
	\'95	Add:\
	\'95	humanIds: [String]\
	\'95	selectedEntityId: String? (instead of separate selectedZombieId / selectedHumanId)\
	\'95	Zombie row:\
	\'95	highlight if selectedEntityId == zombieIds[index]\
	\'95	Human row:\
	\'95	render up to 3 
\f1 \uc0\u55357 \u56898 
\f0  with outline based on selectedEntityId == humanIds[index]\
	\'95	tap index \uc0\u8594  call onHumanTap(index).\
\
So visual behaviour for humans = zombies, just with a different emoji.\
\
\uc0\u11835 \
\
5. Frontend: Interaction panel uses WorldEntity\
\
Files:\
	\'95	ContentView+InteractionSection.swift (your new file)\
	\'95	GameVM+Interaction.swift\
\
Steps:\
	1.	Add helpers in GameVM\
	\'95	interactionEntity: WorldEntity? (like interactionZombie but generic)\
	\'95	interactionHp, interactionMaxHp, interactionHpRatio, interactionHpColor based on interactionEntity.\
	2.	Panel uses those for both zombie + human\
	\'95	If kind == .zombie or .human, show HP bar using interactionEntity.\
	\'95	Button label:\
	\'95	For now: \'93Attack\'94 for both .zombie and .human (future: branch into talk/trade etc.).\
\
\uc0\u11835 \
\
6. Plug in NPCs & items later with zero structural changes\
\
Once the above is done, adding:\
	\'95	Human NPCs (new Firestore collection npcs)\
	\'95	Items (new collection or embedded in tiles)\
\
\'85is just:\
	\'95	New mapping in GameVM+Entities.swift: npcs \uc0\u8594  WorldEntity(kind: .npcHuman); items \u8594  WorldEntity(kind: .item).\
	\'95	entities(at:) start including them automatically.\
	\'95	Grid rows:\
	\'95	Humans row already uses isHuman \'96 NPCs show up there \'93for free\'94.\
	\'95	Items row already uses isItem.\
\
No changes to selection logic, interaction panel, or backend attack math.\
\
\uc0\u11835 \
\
If you want, next step we can start with Step 2 (WorldEntity in GameVM) since that\'92s the foundation for everything else, then go selection \uc0\u8594  Grid \u8594  panel in one pass so we don\'92t keep reopening the same files.}